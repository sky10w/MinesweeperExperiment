# 扫雷实验

## 要求
阅读game.cpp中的文件，体会接口的意义

完善'类'Board中的成员函数  <-主要


## What have been done
该实验已经预置了一份用户界面，

当然，如果你不喜欢也可以自己写一份

**这里特别提一下base.hpp中的内容**
### struct Cell
Cell是棋盘(或者说地图)上的一个个小元素，也就是“格子”

每个格子有四个属性：
- isBomb : 是否是地雷
- isRevealed : 是否被揭开
- isMarked : 是否被标记
- bombNum : 周围八格内的炸弹个数

### struct Point
Point代表一个坐标，你可以这样使用它:

```c++
Point pt_1 = {8, 5};
printf("pt 代表的坐标是(%d, %d)", pt.x, pt.y);

// 同类之间可以相加减（但不能乘除）
Point pt_2 = {1, 3};
Point pt_sum = pt_1 + pt_2;
printf("pt_1 + pt_2 = (%d, %d)", pt_sum.x, pt_sum.y);
```
***<i>尤其注意：Point的顺序为先列后行，而下文中_map的顺序则为先行后列，可对应地参照后文</i>***

### namespace _Sign
不需要关心这个，这只在打印棋盘时有使用到


## What you need to do in every function

### Board::Board()  (构造函数)
初始化Board中的成员变量(包括_row, _col, _gameover, _map)

但是你只需要进一步初始化_map中的每一个Cell

**你需要做的**
- 在地图上随机放置bombNum个地雷
- 计算每个格子(Cell)周围的地雷个数

### bool Board::reveal(Point pt)
在棋盘(或者说地图)上翻开位于pt位置的格子
- 如果这个格子是*正常的*，那么把它(Cell)的isRevealed置为**true**
- 如果这个格子下是*地雷*，那么将(Board)_gameover置为**2** (代表游戏失败)
- 如果所有*非地雷*的格子都被翻开，则将(Board)_gameover置为**1** (代表游戏胜利)
<br>


你一定会注意到这个b函数居然还有返回值，没错：
<br>
这个返回值代表该函数是否执行成功，如果不成功，那么会**要求用户再次输入**(下面的mark同理)

**注意:当翻开一个<i>已被标记的格子</i>时，应当向用户再次确认**

### bool Board::mark(Point pt)
在棋盘上标记一个格子为炸弹，顾名思义。<br>
返回值与reveal同理

**注意:当标记一个<i>已被标记的格子</i>时，相当于将该格子取消标记**
<br>
**注意:_map的顺序则为先行后列(_map[行][列])，而上文中Point的顺序为先列后行，可对应地参照前文**


## At Last
其实不一定要把所有代码都挤在这两个函数里
<br>
鼓励将常用的代码**单独**列为一个函数（这就是封装）
<br>
还有，写的时候仔细想想一些情况，例如:
- 当访问超过边界（如_map[-1][10000]）
- 如果用户翻开了一个已经翻开的格子，那应当输出提示信息

### 一点小拓展：怎样“连锁翻开”
玩过扫雷都知道，如果点到了一个周围8格都没有雷的格子（‘0’格子），系统会将这8个格子**自动**都翻开。<br>
如果被自动翻开的格子里还有‘0’格子，则会**继续自动翻开**<br>
想想这是怎么实现的

### 一点小提示：为什么我的程序编译都过不了
想想访问_map的时候，是不是越界了？（ _map[ 0~row-1 ][ 0~col-1 ]）
<br>
尝试写一个**函数**来判断这种情况


<h1>写得愉快 ;-)</h1>